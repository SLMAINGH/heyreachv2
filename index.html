<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HeyReach Conversation Dashboard V2 (Optimized)</title>
    <style>
        body { font-family: sans-serif; margin: 2em; }
        div { margin-bottom: 1em; }
        label { display: block; margin-bottom: 0.5em; }
        button { cursor: pointer; padding: 8px 12px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        #thread-preview {
            position: fixed; top: 10%; left: 10%; width: 80%; height: 80%;
            background: white; border: 2px solid #333; overflow: auto;
            padding: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 100;
        }
    </style>
</head>
<body>
    <div id="config-section">
        <h2>Konfiguracja</h2>
        <div>
            <label>Hasło: <input type="password" id="auth-password" placeholder="Wprowadź hasło"></label>
        </div>
        
        <h3>Wybierz klucze API:</h3>
        <div id="api-keys">
            <label><input type="checkbox" value="ICP"> ICP</label>
            <label><input type="checkbox" value="account2"> account2</label>
            <label><input type="checkbox" value="account3"> account3</label>
        </div>
        
        <button id="fetch-data-btn">Pobierz Dane</button>
        <div id="loading" style="display:none;">Ładowanie... (To może potrwać, zależnie od ilości danych)</div>
        <div id="error-msg" style="color:red;"></div>
    </div>

    <hr>

    <div id="filters-section" style="display:none;">
        <h2>Filtry</h2>
        
        <div>
            <label><input type="checkbox" id="filter-has-response"> Pokaż tylko z odpowiedzią</label>
        </div>
        
        <div>
            <h4>Klucz API:</h4>
            <div id="filter-api-keys"></div>
        </div>
        
        <div>
            <h4>Osoba wysyłająca:</h4>
            <div id="filter-senders"></div>
        </div>
        
        <div>
            <h4>Kampania:</h4>
            <div id="filter-campaigns"></div>
        </div>
        
        <button id="apply-filters-btn">Zastosuj filtry</button>
    </div>

    <hr>

    <div id="stats-section" style="display:none;">
        <h2>Statystyki</h2>
        <div>Liczba rozpoczętych wątków: <span id="stats-total">0</span></div>
        <div>Liczba konwersacji z odpowiedzią: <span id="stats-with-response">0</span></div>
        <div>Współczynnik odpowiedzi: <span id="stats-response-rate">0%</span></div>
    </div>

    <hr>

    <div id="conversations-section" style="display:none;">
        <h2>Konwersacje</h2>
        <button id="export-csv-btn">Pobierz jako CSV</button>
        <table id="conversations-table" border="1">
            <thead>
                <tr>
                    <th>Imię i Nazwisko</th>
                    <th>Ostatnia wiadomość</th>
                    <th>Kampania</th>
                    <th>Klucz API</th>
                    <th>Akcja</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <div id="thread-preview" style="display:none;">
        <h3>Szczegóły konwersacji</h3>
        <button id="close-thread" style="position: absolute; top: 10px; right: 10px;">Zamknij</button>
        <div id="thread-content"></div>
    </div>

    <script type="module">
        // TypeScript interfaces are kept as comments for documentation
        /* ... interfaces ... */

        const state = {
            workerUrl: 'https://snowy-hall-5f3d.lammelstanislaw.workers.dev',
            authPassword: '',
            selectedApiKeys: [],
            accounts: [],
            campaigns: [],
            conversations: [],
            filteredConversations: [],
            filters: { hasResponse: false, apiKeys: [], senderIds: [], campaignIds: [] }
        };

        // Helper for API calls
        async function apiCall(endpoint, method = 'GET', body = null, apiKeyAlias = null) {
            const headers = {
                'X-Custom-Auth': state.authPassword,
                'Content-Type': 'application/json'
            };
            if (apiKeyAlias) headers['X-API-KEY'] = apiKeyAlias;

            const options = { method, headers };
            if (body && method === 'POST') options.body = JSON.stringify(body);
            
            const response = await fetch(state.workerUrl + endpoint, options);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
            }
            return response.json();
        }

        // OPTIMIZATION 1: Fetch all data in parallel
        async function fetchData() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error-msg');
            
            loadingEl.style.display = 'block';
            errorEl.textContent = '';

            try {
                // Reset state
                state.accounts = [];
                state.campaigns = [];
                state.conversations = [];

                // Step 1: Create promises to fetch initial data (accounts, campaigns, conversations) for each API key in parallel.
                const dataPromises = state.selectedApiKeys.map(async (apiKey) => {
                    // Fetch all conversations for one key with pagination
                    const fetchAllConversations = async () => {
                        let allItems = [];
                        let offset = 0;
                        const limit = 100;
                        let hasMore = true;
                        while (hasMore) {
                            const data = await apiCall('/api/public/inbox/GetConversations', 'POST', { offset, limit, filters: {} }, apiKey);
                            const items = data.items || [];
                            items.forEach(conv => conv.apiKeyAlias = apiKey);
                            allItems.push(...items);
                            offset += limit;
                            hasMore = items.length === limit && offset < data.totalCount;
                        }
                        return allItems;
                    };
                    
                    // Run requests for accounts, campaigns, and conversations concurrently for this key
                    const [accountsData, campaignsData, conversations] = await Promise.all([
                        apiCall('/api/public/li_account/GetAll', 'POST', { offset: 0, limit: 100 }, apiKey),
                        apiCall('/api/public/campaign/GetAll', 'POST', { offset: 0, limit: 100 }, apiKey),
                        fetchAllConversations()
                    ]);

                    const accounts = accountsData.items || [];
                    accounts.forEach(acc => acc.apiKeyAlias = apiKey);

                    const campaigns = campaignsData.items || [];
                    campaigns.forEach(camp => camp.apiKeyAlias = apiKey);

                    return { accounts, campaigns, conversations };
                });

                // Execute all promises and wait for them to settle
                const results = await Promise.allSettled(dataPromises);
                
                // Process results
                results.forEach(result => {
                    if (result.status === 'fulfilled') {
                        const { accounts, campaigns, conversations } = result.value;
                        state.accounts.push(...accounts);
                        state.campaigns.push(...campaigns);
                        state.conversations.push(...conversations);
                    } else {
                        console.error("Error fetching data for one of the keys:", result.reason);
                        errorEl.textContent += `Błąd pobierania danych: ${result.reason.message}\n`;
                    }
                });

                // Step 2: Fetch all chatroom details in parallel to avoid the N+1 problem.
                const chatroomPromises = state.conversations.map(conv =>
                    apiCall(`/api/public/inbox/GetChatroom/${conv.linkedInAccountId}/${conv.id}`, 'GET', null, conv.apiKeyAlias)
                        .catch(err => ({ error: true, message: err.message })) // Catch errors individually
                );

                const chatroomResults = await Promise.allSettled(chatroomPromises);

                chatroomResults.forEach((result, index) => {
                    const conv = state.conversations[index];
                    if (result.status === 'fulfilled' && !result.value.error) {
                        const chatroom = result.value;
                        conv.fullData = chatroom;
                        conv.hasResponse = chatroom.messages?.some(msg => msg.sender === 'correspondentProfile') || false;
                    } else {
                        console.error(`Error fetching chatroom for ${conv.id}:`, result.reason || result.value.message);
                        conv.hasResponse = false;
                        conv.fullData = null; // Ensure no stale data
                    }
                });
                
                // Show UI
                createFilters();
                showSections();
                applyFilters();

            } catch (error) {
                errorEl.textContent = `Błąd: ${error.message}`;
            } finally {
                loadingEl.style.display = 'none';
            }
        }

        // Create dynamic filter checkboxes
        function createFilters() {
            const createCheckbox = (container, items, valueField, nameField) => {
                container.innerHTML = '';
                const uniqueItems = [...new Map(items.map(item => [item[valueField], item])).values()];
                uniqueItems.forEach(item => {
                    const label = document.createElement('label');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = item[valueField];
                    checkbox.checked = true;
                    checkbox.addEventListener('change', applyFilters);
                    
                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(' ' + nameField(item)));
                    container.appendChild(label);
                });
            };

            createCheckbox(
                document.getElementById('filter-api-keys'),
                [...new Set(state.conversations.map(c => c.apiKeyAlias))].map(key => ({ key })),
                'key',
                item => item.key
            );

            createCheckbox(
                document.getElementById('filter-senders'),
                state.accounts,
                'id',
                sender => `${sender.firstName} ${sender.lastName}`
            );

            createCheckbox(
                document.getElementById('filter-campaigns'),
                state.campaigns,
                'id',
                campaign => campaign.name
            );
        }

        // Apply filters and update view
        function applyFilters() {
            state.filters.hasResponse = document.getElementById('filter-has-response').checked;
            state.filters.apiKeys = [...document.querySelectorAll('#filter-api-keys input:checked')].map(cb => cb.value);
            state.filters.senderIds = [...document.querySelectorAll('#filter-senders input:checked')].map(cb => parseInt(cb.value)).filter(id => !isNaN(id));
            state.filters.campaignIds = [...document.querySelectorAll('#filter-campaigns input:checked')].map(cb => parseInt(cb.value)).filter(id => !isNaN(id));

            state.filteredConversations = state.conversations.filter(conv => {
                if (state.filters.hasResponse && !conv.hasResponse) return false;
                if (state.filters.apiKeys.length > 0 && !state.filters.apiKeys.includes(conv.apiKeyAlias)) return false;
                if (state.filters.senderIds.length > 0 && !state.filters.senderIds.includes(conv.linkedInAccountId)) return false;
                if (state.filters.campaignIds.length > 0) {
                    if (!conv.campaignId) return false; // Odrzuć konwersacje bez kampanii
                    if (!state.filters.campaignIds.includes(conv.campaignId)) return false; // Odrzuć inne kampanie
                }
                return true;
            });

            updateConversationsTable();
            updateStats();
        }

        // OPTIMIZATION 2: Use DocumentFragment for faster DOM updates
        function updateConversationsTable() {
            const tbody = document.querySelector('#conversations-table tbody');
            const fragment = document.createDocumentFragment();
            
            // Create a lookup map for campaigns for faster access
            const campaignMap = new Map(state.campaigns.map(c => [c.id, c]));

            state.filteredConversations.forEach(conv => {
                const campaign = campaignMap.get(conv.campaignId);
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${conv.correspondentProfile?.firstName || ''} ${conv.correspondentProfile?.lastName || ''}</td>
                    <td>${conv.lastMessageText || 'Brak wiadomości'}</td>
                    <td>${campaign?.name || 'Brak kampanii'}</td>
                    <td>${conv.apiKeyAlias}</td>
                    <td><button class="open-thread-btn" data-conv-id="${conv.id}">Otwórz wątek</button></td>
                `;
                fragment.appendChild(row);
            });
            
            tbody.innerHTML = ''; // Clear the table body once
            tbody.appendChild(fragment); // Append all rows in one operation
        }
        
        // Update dashboard statistics
        function updateStats() {
            const total = state.filteredConversations.length;
            const withResponse = state.filteredConversations.filter(c => c.hasResponse).length;
            const responseRate = total > 0 ? ((withResponse / total) * 100).toFixed(2) : 0;

            document.getElementById('stats-total').textContent = total;
            document.getElementById('stats-with-response').textContent = withResponse;
            document.getElementById('stats-response-rate').textContent = `${responseRate}%`;
        }

        // Show thread preview
        window.openThread = (conversationId) => {
            const threadDiv = document.getElementById('thread-preview');
            const contentDiv = document.getElementById('thread-content');
            
            threadDiv.style.display = 'block';
            contentDiv.innerHTML = 'Ładowanie...';

            const conversation = state.conversations.find(c => c.id === conversationId);
            if (!conversation || !conversation.fullData) {
                contentDiv.innerHTML = `<p style="color:red;">Błąd: nie znaleziono pełnych danych konwersacji. Spróbuj odświeżyć.</p>`;
                return;
            }
            const data = conversation.fullData;

            let html = `
                <h4>Rozmówca: ${data.correspondentProfile?.firstName} ${data.correspondentProfile?.lastName}</h4>
                <p>Firma: ${data.correspondentProfile?.companyName || 'Brak'}</p>
                <p>Stanowisko: ${data.correspondentProfile?.position || 'Brak'}</p>
                <hr>
                <h4>Historia wiadomości:</h4>
            `;

            if (data.messages && data.messages.length > 0) {
                data.messages.forEach(msg => {
                    const senderName = msg.sender === 'linkedInAccount' 
                        ? `${data.linkedInAccount.firstName} ${data.linkedInAccount.lastName} (Ty)` 
                        : `${data.correspondentProfile?.firstName} ${data.correspondentProfile?.lastName}`;
                    html += `
                        <div style="margin: 10px 0; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                            <strong>${senderName}</strong> - ${new Date(msg.createdAt).toLocaleString()}<br>
                            ${msg.subject ? `<em>Temat: ${msg.subject}</em><br>` : ''}
                            ${msg.body}
                        </div>
                    `;
                });
            } else {
                html += '<p>Brak wiadomości w tym wątku.</p>';
            }
            contentDiv.innerHTML = html;
        };
        
        // OPTIMIZATION 3: Use Maps for faster lookups in CSV export
        function exportToCSV() {
            const csvRows = [];
            const headers = ['conversationId', 'campaignName', 'senderFullName', 'correspondentFullName', 'correspondentCompany', 'correspondentPosition', 'hasResponse', 'lastMessageText', 'lastMessageAt', 'apiKeyAlias'];
            csvRows.push(headers.join(','));

            // Create lookup maps once before the loop
            const campaignMap = new Map(state.campaigns.map(c => [c.id, c.name]));
            const accountMap = new Map(state.accounts.map(a => [a.id, `${a.firstName} ${a.lastName}`]));

            const escapeCSV = (str) => `"${(str || '').replace(/"/g, '""')}"`;

            state.filteredConversations.forEach(conv => {
                const campaignName = campaignMap.get(conv.campaignId) || '';
                const senderName = accountMap.get(conv.linkedInAccountId) || '';
                const profile = conv.correspondentProfile;

                const row = [
                    conv.id,
                    escapeCSV(campaignName),
                    escapeCSV(senderName),
                    escapeCSV(`${profile?.firstName} ${profile?.lastName}`),
                    escapeCSV(profile?.companyName),
                    escapeCSV(profile?.position),
                    conv.hasResponse ? 'TAK' : 'NIE',
                    escapeCSV(conv.lastMessageText),
                    conv.lastMessageAt || '',
                    conv.apiKeyAlias || ''
                ];
                csvRows.push(row.join(','));
            });

            const csv = csvRows.join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.setAttribute('href', URL.createObjectURL(blob));
            link.setAttribute('download', `heyreach_conversations_${new Date().toISOString().split('T')[0]}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function showSections() {
            ['filters-section', 'stats-section', 'conversations-section'].forEach(id => {
                document.getElementById(id).style.display = 'block';
            });
        }

        // Event listeners
        document.getElementById('fetch-data-btn').addEventListener('click', () => {
            state.authPassword = document.getElementById('auth-password').value;
            state.selectedApiKeys = [...document.querySelectorAll('#api-keys input:checked')].map(cb => cb.value);

            if (!state.authPassword || state.selectedApiKeys.length === 0) {
                document.getElementById('error-msg').textContent = 'Wypełnij hasło i wybierz co najmniej jeden klucz API.';
                return;
            }
            fetchData();
        });

        document.getElementById('apply-filters-btn').addEventListener('click', applyFilters);
        document.getElementById('export-csv-btn').addEventListener('click', exportToCSV);
        document.getElementById('close-thread').addEventListener('click', () => document.getElementById('thread-preview').style.display = 'none');
        document.getElementById('filter-has-response').addEventListener('change', applyFilters);
        
        // Use event delegation for "Otwórz wątek" buttons for better performance
        document.getElementById('conversations-table').addEventListener('click', (event) => {
            if (event.target.classList.contains('open-thread-btn')) {
                const convId = event.target.getAttribute('data-conv-id');
                window.openThread(convId);
            }
        });

    </script>
</body>
</html>
